package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.34

import (
	"context"
	"fmt"
	"virtuozplay/graph/model"
	db "virtuozplay/models"

	"github.com/99designs/gqlgen/graphql"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

// StartPerformance is the resolver for the startPerformance field.
func (r *mutationResolver) StartPerformance(ctx context.Context, songID string) (*model.Performance, error) {
	_ = ctx
	song, err := r.Songs.FindByNanoID(db.NanoID(songID))
	if err != nil {
		return nil, err
	}
	return ToGraphQLPerformance(r.Performances.New(song))
}

// AddNotesToPerformance is the resolver for the addNotesToPerformance field.
func (r *mutationResolver) AddNotesToPerformance(ctx context.Context, id string, notes []*model.InputNote) (*model.Performance, error) {
	_ = ctx
	perf, err := r.Performances.FindInProgressByNanoID(db.NanoID(id))
	if err != nil {
		return nil, err
	}

	errors := make(gqlerror.List, 0)

	for i, note := range notes {
		err = perf.AppendNote(i,
			note.At,
			note.Duration,
			note.Value,
		)
		// Append the invalid notes to the errors list, but only if we haven't reached the limit (to avoid spamming the user)
		if err != nil && uint(len(errors)) < db.NoteValidationLimit {
			errors = append(errors, gqlerror.Wrap(err))
		}
	}
	// Append the notes that are not invalid
	gqlPerf, gqlErr := ToGraphQLPerformance(perf, r.Performances.Update(perf))

	if gqlErr != nil {
		return nil, gqlErr
	}
	if len(errors) > 0 {
		// Return invalid note errors, note that the valid ones are still saved
		return gqlPerf, errors
	}
	return gqlPerf, nil
}

// FinishPerformance is the resolver for the finishPerformance field.
func (r *mutationResolver) FinishPerformance(ctx context.Context, id string) (*model.Performance, error) {
	_ = ctx
	perf, err := r.Performances.FindByNanoID(db.NanoID(id))
	if err != nil {
		return nil, err
	}

	return ToGraphQLPerformance(perf, r.Performances.MarkAsFinished(perf))
}

// DebugCreateSong is the resolver for the debug_createSong field.
func (r *mutationResolver) DebugCreateSong(ctx context.Context, title string) (*model.Song, error) {
	// TODO: TEMPORARY, remove this once we have a proper song creation flow
	_ = ctx
	id, err := db.NewNanoID()
	if err != nil {
		return nil, err
	}
	song := &db.Song{
		NanoID: id,
		Title:  title,
	}
	err = r.Songs.Create(song)
	return &model.Song{
		ID:    string(song.NanoID),
		Title: song.Title,
		Notes: []*model.SongNote{},
	}, wrapError(err)
}

// VirtuozPlay is the resolver for the virtuozPlay field.
func (r *queryResolver) VirtuozPlay(ctx context.Context) (*model.VirtuozPlay, error) {
	_ = ctx
	return &model.VirtuozPlay{Version: "0.1.0"}, nil
}

// Performance is the resolver for the performance field.
func (r *queryResolver) Performance(ctx context.Context, id string) (*model.Performance, error) {
	fields := graphql.CollectAllFields(ctx)
	nanoID := db.NanoID(id)

	return ToGraphQLPerformance(r.Performances.FindByNanoID(nanoID, fields...))
}

// Songs is the resolver for the songs field.
func (r *queryResolver) Songs(ctx context.Context) ([]*model.Song, error) {
	files, err := ListFilesInDirectory("assets/musicXml")
	if err != nil {
		return nil, err
	}

	musicXMLList, err := ParseXMLFiles(files)
	if err != nil {
		return nil, err
	}

	var songs []*model.Song

	for _, musicXML := range musicXMLList {
		// Create an empty list to store song notes
		var songNotes []*model.SongNote

		// Browse the notes of each XML song and create the corresponding *model.SongNote object
		for _, part := range musicXML.Parts {
			for _, measure := range part.Measures {
				for _, note := range measure.Notes {
					songNote := &model.SongNote{
						Measure:  measure.Number,
						Note:     note.Pitch.Step,
						Fret:     note.Notations.Technical.Fret,
						String:   note.Notations.Technical.String,
						Octave:   note.Pitch.Octave,
						Duration: note.Duration,
						Alter:    note.Pitch.Alter,
						Default:  note.Default,
						Beat:     measure.Beat,
						Type:     note.Type,
					}
					songNotes = append(songNotes, songNote)
				}
				// Create the corresponding *model.Song object with associated notes and add it to the song list

			}
		}
		id, err := db.NewNanoID()
		if err != nil {
			return nil, err
		}
		song := &model.Song{
			ID:    string(id),
			Title: musicXML.Title,
			Notes: songNotes,
		}
		songs = append(songs, song)
	}
	// Return song list populated with musicXMLList data
	return songs, nil
}

// Song is the resolver for the song field.
func (r *queryResolver) Song(ctx context.Context, id string) (*model.Song, error) {
	panic(fmt.Errorf("not implemented: Song - song"))
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
